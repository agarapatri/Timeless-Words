<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Enable Semantic Search</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="../assets/css/styles.css?v={{VERSION}}" rel="stylesheet" />
</head>

<body>
  <main class="panel">
    <div class="titlebar">
      <h2 class="title" style="margin:0">Enable Semantic Search</h2>
      <!-- On/Off pill switch (matches site pills) -->
      <div class="row" style="justify-content: space-between; margin: 8px 0 4px">
        <strong>Semantic Search</strong>
        <label class="switch" id="semanticSwitch" aria-label="Enable Semantic Search">
          <input id="semanticToggle" type="checkbox" role="switch" aria-checked="false" />
          <span class="track"><span class="thumb"></span></span>
        </label>
      </div>

    </div>

    <p class="muted">We’ll download a compact model and index once (≈ 70–120&nbsp;MB) and keep it cached on your device.
      Works offline. Private—no data leaves your browser.</p>

    <div class="row">
      <progress id="bar" value="0" max="100"></progress>
      <span id="pct" class="muted">0%</span>
    </div>
    <div id="status" class="muted">Ready.</div>

    <div class="actions">
      <button id="btn-download" class="btn">Download &amp; Enable</button> <!-- ← use .btn -->
      <button id="btn-cancel" class="btn ghost">Cancel</button> <!-- ← use ghost -->
      <button id="btn-delete" class="btn ghost">Delete Pack</button> <!-- ← use ghost -->
    </div>

    <details style="margin-top:12px">
      <summary>What gets downloaded? <span id="totalSize" class="muted"></span></summary> <!-- ← total -->
      <ul id="file-list" class="muted"></ul>
    </details>
  </main>

  <!-- Switch wiring that reflects localStorage (no logic changes to your downloader) -->
  <script type="module">
    import { SemanticInstall } from '../js/semantic_downloader.js';

    const ENABLE_KEY = 'tw_semantic_enabled';
    const VERSION_KEY = 'tw_semantic_version';

    const toggle = document.getElementById('semanticToggle');
    const statusEl = document.getElementById('status');

    const sem = new SemanticInstall({
      panelId: null, barId: 'bar', pctId: 'pct', statusId: 'status',
      cancelId: 'btn-cancel', deleteId: 'btn-delete', sizeId: null
    });

    const isEnabled = () => localStorage.getItem(ENABLE_KEY) === '1';
    const setEnabled = (v) => v ? localStorage.setItem(ENABLE_KEY, '1')
      : localStorage.removeItem(ENABLE_KEY);

    async function refreshUI() {
      const installed = await sem.isInstalled();
      toggle.checked = isEnabled();
      toggle.setAttribute('aria-checked', String(toggle.checked));
      document.getElementById('btn-delete').disabled = !installed;
    }

    // Change = user flipped the checkbox (via keyboard or our handlers)
    toggle.addEventListener('change', async (e) => {
      const wantOn = e.target.checked;
      const installed = await sem.isInstalled();
      if (wantOn && !installed) {
        statusEl.textContent = 'Downloading semantic pack…';
        sem.onInstalled = () => { setEnabled(true); refreshUI(); };
        await sem.start();
        return;
      }
      setEnabled(wantOn);
      refreshUI();
    });

    // CLICK support on the visual track (so it flips even if label forwarding fails)
    (function wireClickToToggle() {
      const track = document.querySelector('#semanticSwitch .track');
      track.addEventListener('click', (ev) => {
        // If we just finished a drag, skip the extra click
        if (track.classList.contains('just-dragged')) {
          track.classList.remove('just-dragged');
          return;
        }
        toggle.checked = !toggle.checked;
        toggle.dispatchEvent(new Event('change', { bubbles: true }));
      });
    })();

    // DRAG support (iOS-like)
    (function dragSwitch() {
      const track = document.querySelector('#semanticSwitch .track');
      const thumb = track.querySelector('.thumb');
      let dragging = false, startX = 0, startChecked = false;

      const onDown = (ev) => {
        dragging = true;
        startX = (ev.touches?.[0]?.clientX ?? ev.clientX);
        startChecked = toggle.checked;
        track.classList.add('dragging');
        ev.preventDefault();
      };
      const onMove = (ev) => {
        if (!dragging) return;
        const x = (ev.touches?.[0]?.clientX ?? ev.clientX);
        const dx = x - startX;
        const threshold = 14; // px
        const wantOn = dx > threshold ? true : dx < -threshold ? false : startChecked;
        track.style.setProperty('--thumb-shift', wantOn ? '20px' : '0px');
      };
      const onUp = async (ev) => {
        if (!dragging) return;
        dragging = false;
        track.classList.remove('dragging');
        track.style.removeProperty('--thumb-shift');

        const x = (ev.changedTouches?.[0]?.clientX ?? ev.clientX);
        const dx = x - startX;
        const threshold = 14;
        const wantOn = dx > threshold ? true : dx < -threshold ? false : startChecked;

        if (wantOn !== toggle.checked) {
          toggle.checked = wantOn;
          // Mark that a drag completed to ignore the synthetic click that follows on some browsers
          track.classList.add('just-dragged');
          toggle.dispatchEvent(new Event('change', { bubbles: true }));
        }
      };

      const start = (e) => onDown(e);
      const move = (e) => onMove(e);
      const end = (e) => onUp(e);

      track.addEventListener('mousedown', start);
      track.addEventListener('touchstart', start, { passive: false });
      window.addEventListener('mousemove', move, { passive: true });
      window.addEventListener('touchmove', move, { passive: true });
      window.addEventListener('mouseup', end);
      window.addEventListener('touchend', end);
    })();

    // init
    refreshUI();
  </script>

</body>

</html>
